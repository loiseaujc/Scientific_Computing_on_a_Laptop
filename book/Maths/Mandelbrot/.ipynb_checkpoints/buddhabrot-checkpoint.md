---
jupytext:
  formats: md:myst
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.10.3
kernelspec:
  display_name: Python 3 (ipykernel)
  language: python
  name: python3
---

```{code-cell} ipython3
:tags: [remove-cell]

import numpy as np
import numba
import matplotlib.pyplot as plt

@numba.jit(nopython=True)
def in_main_cardioid(c):
    q = (c.real - 1/4)**2 + c.imag**2
    return q*(q + (c.real - 1/4)) <= c.imag**2/4

@numba.jit(nopython=True)
def in_period2bulb(c):
    return (c.real + 1)**2 + c.imag**2 <= 1/16

@numba.vectorize(nopython=True)
def mandelbrot(c, maxiter):
    # --> Check if point is in main cardioid.
    if in_main_cardioid(c): return True
    if in_period2bulb(c): return True
    
    # --> If not, check if it is nonetheless in the
    #     Mandelbrot set.
    x, y = c.real, c.imag
    x2, y2 = x*x, y*y
    for i in range(maxiter):
        if (x2 + y2) > 4:
            return False
            
        y = 2*x*y + c.imag
        x = x2 - y2 + c.real
        x2, y2 = x*x, y*y

    return True
```

# The Buddhabrot

Now that we know how to make simple visualizations of the Mandelbrot set, let's turn our attention to more advanced ones.
Among all of the different ways to visualize this fractal object, the most computation-intensive one is probably the [Buddhabrot](https://en.wikipedia.org/wiki/Buddhabrot).
One of its numerous renderings is shown below.

<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/26/Nebulabrot_%285000%2C_500%2C_50%29.png/600px-Nebulabrot_%285000%2C_500%2C_50%29.png" width="512px" align="center" margin="16px" />

</br>

In the previous section, we made visualizations highlighting if a point $c \in \mathbb{C}$ is in the Mandelbrot (or not) or how fast the dynamical system $z_{k+1} = z^2_k + c$ escaped to infinity.
The Buddhabrot is an entirely different beast.
Rather than focusing on $c$, it depicts the probability distribution over trajectories of points escaping the Mandelbrot set, i.e. the probability distribution of the sequence $z_{k+1} = z^2_k + c$ for all $c$'s outside the Mandelbrot set.
Hence, not only do we need to determine if $c$ is the Mandelbrot set, but we also need to keep track of the whole trajectory generated by the associated quadratic function.
And we need to make sure the image looks nice!

Rendering high resolution images of the Buddhabrot as shown above can be incredibly computation-intensive.
Millions, if not billions of unstable trajectories need to be sampled.
These computations can be even more intensive if one wants to zoom in or do an animation.
Benedikt Bitterli has a nice series of [blog posts](https://benedikt-bitterli.me/buddhabrot/) describing how he's been able to render [this video](https://www.youtube.com/watch?v=zxIcydL7wwY&ab_channel=Thunabrain).
In the rest of this section, we'll only try to produce a low-resolution image (300 x 300 pixels) of the Buddhabrot.
This is already challenging enough!
It will nonetheless show the basic techniques or ideas you can use to produce higher resolution images (caution: if you do so, the computational cost will increase drastically).


## Simulating a trajectory

The Buddhabrot is the probability distribution over trajectories of points escaping the Mandelbrot.
Getting a good estimate of this probability distribution requires the computation of an extremely large number of such trajectories.
Hence, this is the portion of the code that we need to optimize as much as possible.
Fortunately, most of the work has already been done in the previous section.

```{code-cell} ipython3
@numba.jit(nopython=True)
def trajectory(c, maxiter):
    # --> Compute trajectory.
    z = np.zeros((maxiter, 2), dtype=numba.float64)
    
    x, y = c.real, c.imag
    z[0] = x, y
    x2, y2 = x*x, y*y
    
    for i in range(1, maxiter):
        
        # --> Update point.
        y = 2*x*y + c.imag
        x = x2 - y2 + c.real
        x2, y2 = x*x, y*y
        
        z[i] = x, y

        # --> Check bailout condition.
        if (x2 + y2) > 4:
            break

    return z[:i+1]
```

The function `trajectory` is almost identical to the function `mandelbrot` we wrote earlier.
It takes as input the value of $c \in \mathbb{C}$ that we consider and the maximum number of iterations `maxiter` beyond which we consider $c$ to be in the Mandelbrot set.
However, it no longer returns `True` or `False`.
Instead, it returns the computed trajectory `z`.
This is pretty much the only difference with our previous piece of code.

## Simple sampling of the trajectories

We know how to simulate efficiently a given trajectory.
Now, how do we estimate the probability distribution?
To do so, we need to sample a large number of different $c$ values and simulate the corresponding trajectories.
If a given trajectory reaches the maximum number of iterations `maxiter`, it is rejected and a new value for $c$ is sampled.
The probability distribution of our data is then obtained using a simple 2D histogram (see `np.histogram2d` for more details).
This process is re-iterated until our estimate converges.

The question thus boils down to **how to sample the $c$ values?**
Sampling the complex plane $\mathbb{C}$ uniformly is probably the simplest thing to do.
Yet, it would be extremely slow.
However, we do know a few things about the Mandelbrot set
- If $c$ is in the main cardioid, it is in the Mandelbrot set.
Hence, we do not even need to simulate the corresponding trajectory.
- Similarly, if $c$ is the circle centered around $x + i y$ and of radius $z$, it is in the Mandelbrot set.
Once again, we don't need to simulate the corresponding trajectory.
- If $\vert c \vert > 2$, $c$ is the not the set.
Moreover, the sequence $z_{k+1} = z_k^2 + c$ grows exponentially fast. Hence, the corresponding trajectory would not contribute much to the overall probability distribution (at least not in the region of the complex plane we are interested in).
Once again, we wouldn't need to simulate it.

Our first sampling strategy is thus fairly simple:
1. Sample $c$ uniformly in a disk of radius 2 centered at the origin.
2. If $c$ is in the cardioid or in the period-2 bulb, reject it and go back to 1.
Otherwise, compute the corresponding sequence $\left\{ z_k \right\}$.
3. If the sequence $\left\{ z_k \right\}$ reached the maximum number of iterations allowed, reject it and go back to 1. Otherwise, add it to our dataset.

This process is repeated until we have collected a sufficiently large number of unstable trajectories.
Once this is done, the probability distribution is estimated using a 2D histogram.
The number of bins in each direction will determine the size of the Buddhabrot image we'll render.

The next few cells implement the different steps of our algorithm.
The code should be pretty self-explanatory.

```{code-cell} ipython3
def uniform_sampling():
    r = np.random.uniform(0, 2)
    theta = np.random.uniform(-np.pi, np.pi)
    c = r * np.exp(1j*theta)
    
    while in_main_cardioid(c) or in_period2bulb(c):
        return uniform_sampling()
    else:
        return c
```

```{code-cell} ipython3
def sample_trajectory(maxiter, get_new_sample):

    rejected = True
    
    # --> Sample new trajectory if needed.
    while rejected:
        # --> Sample new c value.
        c = get_new_sample()
        
        # --> New candidate trajectory.
        z = trajectory(c, maxiter)
        
        # --> Check whether it escaped or not.
        rejected = len(z) == maxiter
    else:
        return z
```

```{code-cell} ipython3
def generate_data(n, maxiter, get_new_sample):
    
    # --> Initial trajectory.
    z = sample_trajectory(maxiter, get_new_sample)
    
    # --> Add new trajectories to the dataset.
    while len(z) < n:
        k = len(z)
        z = np.append(z, sample_trajectory(maxiter, get_new_sample), axis=0)
    else:
        return z
```

```{code-cell} ipython3
def compute_image(
    n, 
    maxiter=100, 
    get_new_sample=uniform_sampling,
    nx=301, ny=301):
    
    # --> Generate data.
    data = generate_data(n, maxiter, get_new_sample)
    
    # --> Generate image.
    cr, ci = np.linspace(-2, 2, nx), np.linspace(-2, 2, ny)
    H, _, _ = np.histogram2d(data[:, 0], data[:, 1], bins=[cr, ci])
    
    return H
```

Let's now generate a 300 x 300 image of the Buddhabrot.
We'll sample enough trajectories to have at least 1 000 000 points from which to estimate the probability distribution.

```{code-cell} ipython3
%%time
H_naive = compute_image(nsamples := 10**6, maxiter := 1000)
```

On my laptop, this computation takes 5 to 8 minutes depending on what I'm doing on the side.

```{code-cell} ipython3
---
render:
  image:
    align: center
tags: [hide-input]
---
fig, ax = plt.subplots(1, 1, figsize=(8, 8))
ax.imshow(
    H_naive, 
    cmap=plt.cm.inferno, 
    extent=[-2, 2, -2, 2],
    interpolation="bicubic"
)

ax.set_aspect("equal")
ax.set_xlim(-1.75, 1.75)
ax.set_ylim(-1.25, 1.75)
ax.axis(False);
```

## A smarter sampling strategy

### Edge detection using Sobel filter

```{code-cell} ipython3
from scipy.ndimage import sobel

# --> Complex plane.
nx, ny = 3001, 2501
cr = np.linspace(-2.25, 0.75, nx)
ci = np.linspace(-1.25, 1.25, ny)
c = cr[:, None] + 1j*ci[None, :]

# --> Compute the Mandelbrot set.
M = mandelbrot(c, maxiter)

# --> Compute its edges.
edges = np.abs(sobel(M, axis=0)) + np.abs(sobel(M, axis=1))
```

```{code-cell} ipython3
---
render:
  image:
    align: center
tags: [remove-input]
---
# --> Plot the Mandelbrot set.
fig, axes = plt.subplots(1, 2, figsize=(16, 8))

axes[0].imshow(
    M, 
    extent=[ci.min(), ci.max(), cr.min(), cr.max()],
    cmap=plt.cm.binary)
    
axes[0].set_title("Mandelbrot set")

axes[1].imshow(
    edges, 
    extent=[ci.min(), ci.max(), cr.min(), cr.max()],
    cmap=plt.cm.binary)

axes[1].set_title("Edges of the Mandelbrot set")

for ax in axes:
    ax.set_aspect("equal")
    ax.axis(False);
```

```{code-cell} ipython3
# --> Points from which to sample.
cs = c[edges == True].ravel()

# --> Scale of the perturbation to be added.
Δx, Δy = cr[1] - cr[0], ci[1]-ci[0]
```

```{code-cell} ipython3
def smart_sampling(cs, Δx, Δy):

    # --> Perturbation to be added to the sampled point.
    Δcr = np.random.uniform(-Δx/2, Δx/2)
    Δci = np.random.uniform(-Δy/2, Δy/2)
    
    Δc = Δcr + 1j*Δci
    
    # --> Value of c to be tested.
    idx = np.random.randint(len(cs))
    c = cs[idx] + Δc
    
    while in_main_cardioid(c) or in_period2bulb(c) or np.abs(c)>2:
        return smart_sampling(cs, Δx, Δy)
    else:
        return c
```

```{code-cell} ipython3
%%time
H_edges = compute_image(nsamples, maxiter=maxiter, get_new_sample=lambda : smart_sampling(cs, Δx, Δy))
```

### Plotting the Buddhabrot

```{code-cell} ipython3
---
render:
  image:
    align: center
tags: [hide-input]
---
fig, axes = plt.subplots(1, 2, figsize=(16, 8), sharex=True, sharey=True)

axes[0].imshow(
    H_naive, 
    cmap=plt.cm.inferno, 
    extent=[-2, 2, -2, 2],
    interpolation="bicubic"
)

axes[0].set_title("Uniform sampling")

axes[1].imshow(
    H_edges, 
    cmap=plt.cm.inferno, 
    extent=[-2, 2, -2, 2],
    interpolation="bicubic"
)

axes[1].set_title("Sampling from the edges")

for ax in axes:
    ax.set_aspect("equal")
    ax.axis(False);
    ax.set_xlim(-1.75, 1.75)
    ax.set_ylim(-1.25, 1.75)
```

```{code-cell} ipython3
---
render:
  image:
    align: center
tags: [hide-input]
---
from matplotlib import colors
p = 1/2

fig, axes = plt.subplots(1, 2, figsize=(16, 8), sharex=True, sharey=True)

axes[0].imshow(
    H_naive, 
    cmap=plt.cm.inferno, 
    extent=[-2, 2, -2, 2],
    norm=colors.PowerNorm(p),
    interpolation="bicubic"
)

axes[0].set_title("Uniform sampling")

axes[1].imshow(
    H_edges,
    cmap=plt.cm.inferno, 
    extent=[-2, 2, -2, 2],
    norm=colors.PowerNorm(p),
    interpolation="bicubic"
)

axes[1].set_title("Sampling from the edges")

for ax in axes:
    ax.set_aspect("equal")
    ax.axis(False);
    ax.set_xlim(-1.75, 1.75)
    ax.set_ylim(-1.25, 1.75)
```

## To go further

```{code-cell} ipython3
from joblib import Parallel, delayed, cpu_count
def compute_image(
    n, 
    maxiter=100, 
    get_new_sample=uniform_sampling,
    nx=301, ny=301,
    n_jobs=cpu_count()):
    
    # --> Generate data.
    if n_jobs == 1:
        data = generate_data(n, maxiter, get_new_sample)
    else:
        data = Parallel(n_jobs=n_jobs)(delayed(generate_data)(n//n_jobs, maxiter, get_new_sample) for i in range(n_jobs))
        data = np.concatenate(data)

    # --> Generate image.
    cr, ci = np.linspace(-2, 2, nx), np.linspace(-2, 2, ny)
    H, _, _ = np.histogram2d(data[:, 0], data[:, 1], bins=[cr, ci])
    
    return H
```

```{code-cell} ipython3
%%time
H = compute_image(10**7, maxiter=maxiter, get_new_sample=lambda : smart_sampling(cs, Δx, Δy))
```

```{code-cell} ipython3
fig, ax = plt.subplots(1, 1, figsize=(8, 8))
ax.imshow(
    H, 
    cmap=plt.cm.inferno, 
    extent=[-2, 2, -2, 2],
    interpolation="bicubic",
    norm=colors.PowerNorm(p)
)
    
ax.set_aspect("equal")
ax.set_xlim(-1.75, 1.75)
ax.set_ylim(-1.25, 1.75)
ax.axis(False);
```

```{code-cell} ipython3

```
